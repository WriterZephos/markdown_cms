# API Docs

This document describes the routes and controllers provided automatically by MarkdownRecord and provides an example of how to use its Content DSL to define application data right alongside your written markdown content.

## Content DSL

While writing documentation for your API (or any other software, such as this Rails engine), you can define json data using HTML comments which will then be made available to you within your application code (if you define matching models), or directly served via the routes and controllers that with MarkdownRecord.

To do this, simply write an HTML comment like this in your markdown files:

<pre><code class="html">&lt;!--describe_model
  {
    "type": "dsl_command",
    "id":   1,
    "name": "describe_model",
    "example_id": 1
  }
--&gt;
</code></pre>

*Note: you can write these JSON object inline as well to be more concise.*

As you can see, all that is required is a JSON object inside the comment that defines your data. The `describe_model` part of the comment is a DSL commant that tells MarkdownRecord how to process the comment, and in this case it will take your JSON object and include it in its final output and/or make it available via the provided routes and controllers. If this part is missing or unrecognized, then the comment will be treated as a plain HTML comment and nothing will be done with its contents.

There are several different DSL commands that you can use to define application data within your markdown source documents. They are as follows:

<!--describe_model { "type": "dsl_command", "id": 1, "name": "describe_model", "example_id": 1 } -->
<!--describe_model_attribute:description:string-->
- `describe_model` is the main command that tells MarkdownRecord that you want to define a model or json object. The only attribute required in the json object you provide is the `type` attribute, which can be anything as long as you don't plan on using coresponding models. If you *do* plan to use corresponding models, then the `type` attribute should match the fully qualified class name of the model. MarkdownRecord puts each model in a stack structure during rendering, and remembers the order in which models are defined in a single markdown file. This is important, as the next command in this list allows you to add additional attributes where the values are taken from your markdown content itself. The model that attributes get assigned to this way is always the model at the top of the stack.
<!--end_describe_model_attribute-->
<!--describe_model { "type": "dsl_command", "id": 2, "name": "describe_model_attribute", "example_id": 1 } -->
<!--describe_model_attribute:description:string--> 
- `describe_model_attribute:<attribute_name>:<type>` tells MarkdownRecord that any text that follows should be assigned to the top model on the stack as the value of the given attribute, until it sees the `end_describe_model_attribute` command. The `type` part of this command can be `html`, `md`, `int`, `float` or `string` or omitted. MarkdownRecord will process the final value of the attribute differently based on this value. If the type is `html`, it will be rendered into an html string. If it is `md`, then it will be left as is and slightly cleaned up to remove leading and trailing white space. If it is `int` or `float`, it will be parsed accordingly into an numeric value, and if it is `string`, it will be stripped of any markdown syntax and all leading and trailing whitespace will be removed. The `string` option will also cause multiple newlines to be reduced to a single newline. If the type option is omitted, MarkdownRecord will not process the attribute value and it will contain the raw content read from the markdown file.
<!--end_describe_model_attribute-->
<!--describe_model { "type": "dsl_command", "id": 3, "name": "end_describe_model_attribute", "example_id": 1 } -->
<!--describe_model_attribute:description:string-->
- `end_describe_model_attribute` tells MarkdownRecord to stop assigning text as an attribute value to the top model on the stack.
<!--end_describe_model_attribute-->
<!--describe_model { "type": "dsl_command", "id": 4, "name": "end_describe_model", "example_id": 1 } -->
<!--describe_model_attribute:description:string-->
- `end_describe_model` tells MarkdownRecord to pop the top model of the stack.
<!--end_describe_model_attribute-->
<!--describe_model { "type": "dsl_command", "id": 5, "name": "fragment", "example_id": 1 } -->
<!--describe_model_attribute:description:string-->
- `fragment` is similar to `describe_model` in that it expects a JSON object, but the object is assigned to ths `meta` attribute of the `ContentFragment` corresponding to the current markdown file. As such, this command should only be used once in each file. This command provides a way of attaching custom data to ContentFragments, such as a layout you want to use for rendering from a controller, or perhaps access restrictions to limit who might be able to view the rendered document, etc.
<!--end_describe_model_attribute-->
<!--describe_model { "type": "dsl_command", "id": 6, "name": "use_layout", "example_id": 1 } -->
<!--describe_model_attribute:description:string-->
- `use_layout:<path>` simply specifies a layout by its relative file path to use when rendering the current markdown file to HTML. This is useful for when you have specific markdown files that you want to render using a different layout than the layout configured for use with all other files.
<!--end_describe_model_attribute-->

## Routes

- `use_layout:<path>` simply specifies a layout by its relative file path to use when rendering the current markdown file to HTML. This is useful for when you have specific markdown files that you want to render using a different layout than the layout configured for use with all other files.
- `use_layout:<path>` simply specifies a layout by its relative file path to use when rendering the current markdown file to HTML. This is useful for when you have specific markdown files that you want to render using a different layout than the layout configured for use with all other files.
- `use_layout:<path>` simply specifies a layout by its relative file path to use when rendering the current markdown file to HTML. This is useful for when you have specific markdown files that you want to render using a different layout than the layout configured for use with all other files.

If you are reading this document by rendering it from your application, then you will have already ran the Thor command necessary to render the demo content as HTML and JSON. As you might have guesed, the above list of DSL commands is written in markdown alongside actual exampled of their use. A quick look at the actual source files, which were copied into your application, will reveal this. You can also see the HTML and JSON files in the `rendered` directory.

Since the demo content has been rendered as HTML and JSON, you can now view it directly in your browser. The following routes should now resolve successfully:

```
<application root path>/mdr/html/<content_path>`
<application root path>/mdr/json/<content_path>
<application root path>/<content_path>
```

`content_path` in the above routes is the relative path to a rendered file or directory. When you navigate to a path that points to a directory, you will see the concatenated contens of everything that is in that directory.

The `html` routes only return HTML, while the `json` routes only return JSON. The generic route returns either HTML or JSON depending on the requests ACCEPT header.

In addition to the above routes, routes for downloading content are provided as well. They are:

```
<application root path>/mdr/html/download/<content_path>`
<application root path>/mdr/json/download/<content_path>
<application root path>/download/<content_path>
```

The above routes are not enabled by default, but can be enabled if you want to be able to download your rendered content.

<% binding.pry if ::MarkdownRecord::ContentFragment.find("#{subdirectory}/erb_syntax").nil? %>
<%= link_to_markdown_record_html(::MarkdownRecord::ContentFragment.find("#{subdirectory}/erb_syntax")) %>


