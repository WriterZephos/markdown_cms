{"dsl_command":[{"type":"dsl_command","id":1,"name":"describe_model","example_id":1,"subdirectory":"content/api_docs","filename":"overview","description":"describe_model is the main command that tells MarkdownRecord that you want to define a model or json object. The only attribute required in the json object you provide is the type attribute, which can be anything as long as you don't plan on using coresponding models. If you do plan to use corresponding models, then the type attribute should match the fully qualified class name of the model. MarkdownRecord puts each model in a stack structure during rendering, and remembers the order in which models are defined in a single markdown file. This is important, as the next command in this list allows you to add additional attributes where the values are taken from your markdown content itself. The model that attributes get assigned to this way is always the model at the top of the stack."},{"type":"dsl_command","id":2,"name":"describe_model_attribute","example_id":1,"subdirectory":"content/api_docs","filename":"overview","description":"describe_model_attribute:\u003cattribute_name\u003e:\u003ctype\u003e tells MarkdownRecord that any text that follows should be assigned to the top model on the stack as the value of the given attribute, until it sees the end_describe_model_attribute command. The type part of this command can be html, md, int, float or string or omitted. MarkdownRecord will process the final value of the attribute differently based on this value. If the type is html, it will be rendered into an html string. If it is md, then it will be left as is and slightly cleaned up to remove leading and trailing white space. If it is int or float, it will be parsed accordingly into an numeric value, and if it is string, it will be stripped of any markdown syntax and all leading and trailing whitespace will be removed. The string option will also cause multiple newlines to be reduced to a single newline. If the type option is omitted, MarkdownRecord will not process the attribute value and it will contain the raw content read from the markdown file."},{"type":"dsl_command","id":3,"name":"end_describe_model_attribute","example_id":1,"subdirectory":"content/api_docs","filename":"overview","description":"end_describe_model_attribute tells MarkdownRecord to stop assigning text as an attribute value to the top model on the stack."},{"type":"dsl_command","id":4,"name":"end_describe_model","example_id":1,"subdirectory":"content/api_docs","filename":"overview","description":"end_describe_model tells MarkdownRecord to pop the top model of the stack."},{"type":"dsl_command","id":5,"name":"fragment","example_id":1,"subdirectory":"content/api_docs","filename":"overview","description":"fragment is similar to describe_model in that it expects a JSON object, but the object is assigned to ths meta attribute of the ContentFragment corresponding to the current markdown file. As such, this command should only be used once in each file. This command provides a way of attaching custom data to ContentFragments, such as a layout you want to use for rendering from a controller, or perhaps access restrictions to limit who might be able to view the rendered document, etc."},{"type":"dsl_command","id":6,"name":"use_layout","example_id":1,"subdirectory":"content/api_docs","filename":"overview","description":"use_layout:\u003cpath\u003e simply specifies a layout by its relative file path to use when rendering the current markdown file to HTML. This is useful for when you have specific markdown files that you want to render using a different layout than the layout configured for use with all other files."}]}