<style>
  body{
    background-color: black;
    padding: 10px;
  }
  code{
    padding: 0.2em 0.4em;
    margin: 0;
    font-size: 85%;
    white-space: break-spaces;
    background-color: rgb(110 118 129 / 40%);
    border-radius: 6px;
  }
  pre{
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    color: #f2f2f2;
    background-color: #161b22;
    border-radius: 6px;
    font-family: andale mono, monaco, monospace;
    word-wrap: normal;
  }
  pre code{
    color: inherit;
    background-color: inherit;
    font-family: inherit;
    padding: 0px;
    margin: 0;
    font-size: inherit;
    white-space: inherit;
    background-color: inherit;
    border-radius: 0px;
  }
  h1{
    color: #6699ff;
  }
  h2{
    color: #b3ccff;
  }
  h3{
    color: #b3ccff;
  }
  h4{
    color: #b3ccff;
  }
  a{
    color: #33ffcc;
  }
  .container {
    margin-bottom: 10px;
    padding: 10px;
    color: #f2f2f2;
    background-color: #0d1117;
    font-family: trebuchet ms;
    font-size: 16px;
    line-height: 1.5;
  }
  .rendered_at{
    font-size: 12px;
  }
  .navigation ul{
    padding: 0px;
  }
  .navigation li{
    display: inline;
  }
</style>
<div class="container">
  <div class="navigation">
    <ul>
      <li>Breadcrumbs: </li>
      <li><a href="/mdr/content">Demo</a></li>
    </ul>
  </div>
  <style>
    .concatenated{
      border: 1px solid #a5d6ff;
      padding: 10px;
    }
  </style>
  <div class="concatenated">
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--directory_fragment { "name": "Demo", "author": "Bryant Morrill" } -->
      <!--fragment { "name": "Home", "author": "Bryant Morrill" } -->
      <h1>MarkdownRecord</h1>
      <p>Welcome to MarkdownRecord!</p>
      <p>This document will walk you through the many powerful features of MarkdownRecord, and is created with MarkdownRecord itself. Hopefully, you are rendering this page locally from your own application, and will be able to get a peak under the hood to see how it all works by looking directly at the source markdown files.</p>
      <p>If you haven&#39;t installed it locally yet, you can find instructions <a href="/mdr/content/installation">here</a>.</p>
      <p>After following the installation guide, you should see a <code>markdown_record</code> folder inside your application root. This folder contains three subdirectories: <code>content</code>, <code>layouts</code> and <code>rendered</code>.</p>
      <p>Feel free to poke around and explore the files in the directories mentioned above as you go through this guide. They will serve as a great reference to help make sense of the features and concepts described here.</p>
      <h2>Workflow</h2>
      <p>The general workflow while using MarkdownRecord, once installed in your application, is as follows:</p>
      <ol>
        <li>Write markdown content, using the Content DSL to define data within your markdown content.</li>
        <li>Run the provided Thor task to render your markdown content into HTML and JSON.</li>
        <li>Use the built in <code>MarkdownRecord::ContentFragment</code> model to directly reference your rendered content inside your application. </li>
        <li>Use the provided view helpers to link to the rendered content in your application&#39;s views, relying only on the controllers provided by the engine for serving the content if you wish.</li>
        <li>Use model classes inheritiing from <code>MarkdownRecord::Base</code> to interact with your html and json rendered content, taking advantage of the associations you can define manually as well a the automatic associations they have based on content location.</li>
      </ol>
      <p>The next step is to read through the <a href="/mdr/content/rendering_basics">Rendering Basics</a> section to understand the basic rendering proces of markdown source content into HTML and JSON.</p>
      <p>The folowing links will take you to other sections of this guide. Each section builds upon the last, so it is recommended to read through them in order if you are new to MarkdownRecord.</p>
      <ul>
        <li><a href="/mdr/content/content_dsl">Content DSL</a> </li>
        <li><a href="/mdr/content/routes">Routes</a></li>
        <li><a href="/mdr/content/model_basics">Model Basics</a></li>
        <li><a href="/mdr/content/content_frags">Content Fragments</a></li>
        <li><a href="/mdr/content/erb_syntax_and_view_helpers">ERB Syntax and View Helpers</a></li>
        <li><a href="/mdr/content/layouts">Layouts</a></li>
        <li><a href="/mdr/content/custom_models_and_associations">Custom Models and Associations</a></li>
        <li><a href="/mdr/content/controller_helpers">Controller Helpers</a></li>
        <li><a href="/mdr/content/configuration">Configuration</a></li>
        <li><a href="/mdr/content/sandbox">Sandbox</a></li>
      </ul>
      <!--content/home-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/home">content/home</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "name": "Installation", "parent_id": "content/home" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   1, "name": "Installation" } -->
      <h1>Installation</h1>
      <p>This section explains how to install MarkdownRecord into a host application.</p>
      <p>First, add this line to your application&#39;s Gemfile:</p>
      <pre><code class="ruby">gem &quot;markdown_record&quot;
</code></pre>
      <p>And then execute:</p>
      <pre><code class="bash">$ bundle install
</code></pre>
      <p>Then, from the root directory of your application run:</p>
      <pre><code class="bash">$ rails g markdown_record --demo
</code></pre>
      <p><em>Note: if you are already familiar with MarkdownRecord and don&#39;t want to install the demo content, you can omit the --demo argument.</em></p>
      <p>The above command will install the engine, resulting in the following output and changes to your application:</p>
      <pre><code class="bash">      create  markdown_record/content
      create  markdown_record/layouts
      create  markdown_record/rendered
       exist  markdown_record/content
      create  markdown_record/content/controller_helpers.md.erb
      create  markdown_record/content/configuration.md.erb
      create  markdown_record/content/sandbox/foo.md
      create  markdown_record/content/home.md.erb
      create  markdown_record/content/installation.md.erb
      create  markdown_record/content/rendering_basics.md.erb
      create  markdown_record/content/content_dsl.md.erb
      create  markdown_record/content/routes.md.erb
      create  markdown_record/content/model_basics.md.erb
      create  markdown_record/content/content_frags.md.erb
      create  markdown_record/content/erb_syntax_and_view_helpers.md.erb
      create  markdown_record/content/custom_models_and_associations.md.erb
      exist  markdown_record/layouts
      create  markdown_record/layouts/_concatenated_layout.html.erb
      create  markdown_record/layouts/_custom_layout.html.erb
      create  markdown_record/layouts/_file_layout.html.erb
      create  markdown_record/layouts/_global_layout.html.erb
      create  app/assets/images
      create  app/assets/images/ruby-logo.png
      create  config/initializers/markdown_record.rb
      create  Thorfile
      create  lib/tasks/render_content.thor
        gsub  config/routes.rb
</code></pre>
      <p>The files and folders inside <code>markdown_record/content</code> are for demo purposes only, and can be deleted once youare are ready to create your own content.</p>
      <p>By default, MarkdownRecord will look in the <code>markdown_record/content</code> directory for all your content, and all rendered content will be saved to the <code>markdown_record/rendered</code> directory.</p>
      <p>The engine will be mounted in <code>config/routes.rb</code> under the <code>mdr</code> path by default.</p>
      <p>An initializer will be created for you, where you will be able to configure the engine to use different directories and change other default settings. A later section of this guide will provide more details on configuration options.</p>
      <p>A <code>Thorfile</code> and some thor tasks will also be added to your application. These tasks are used to render your content to HTML and JSON.</p>
      <p>The final step in the installation process is to render the demo content that was installed in <code>markdown_record/content</code>. To do so, run this Thor task in your application&#39;s root directory:</p>
      <pre><code class="bash">thor render_content:all -s
</code></pre>
      <p>You should see the following output:</p>
      <pre><code class="bash">---------------------------------------------------------------
rendering html and json content with options {:concat=&gt;true, :deep=&gt;true, :save=&gt;true, :layout=&gt;&quot;_concatenated_layout.html.erb&quot;, :render_content_fragment_json=&gt;true} ...
---------------------------------------------------------------
rendered: /markdown_record/rendered/content_fragments.json
rendered: /markdown_record/rendered/content.json
rendered: /markdown_record/rendered/content/custom_models_and_associations_fragments.json
rendered: /markdown_record/rendered/content/custom_models_and_associations.json
rendered: /markdown_record/rendered/content/erb_syntax_and_view_helpers_fragments.json
rendered: /markdown_record/rendered/content/erb_syntax_and_view_helpers.json
rendered: /markdown_record/rendered/content/content_frags_fragments.json
rendered: /markdown_record/rendered/content/content_frags.json
rendered: /markdown_record/rendered/content/model_basics_fragments.json
rendered: /markdown_record/rendered/content/model_basics.json
rendered: /markdown_record/rendered/content/routes_fragments.json
rendered: /markdown_record/rendered/content/routes.json
rendered: /markdown_record/rendered/content/content_dsl_fragments.json
rendered: /markdown_record/rendered/content/content_dsl.json
rendered: /markdown_record/rendered/content/rendering_basics_fragments.json
rendered: /markdown_record/rendered/content/rendering_basics.json
rendered: /markdown_record/rendered/content/installation_fragments.json
rendered: /markdown_record/rendered/content/installation.json
rendered: /markdown_record/rendered/content/home_fragments.json
rendered: /markdown_record/rendered/content/home.json
rendered: /markdown_record/rendered/content/sandbox_fragments.json
rendered: /markdown_record/rendered/content/sandbox.json
rendered: /markdown_record/rendered/content/sandbox/foo_fragments.json
rendered: /markdown_record/rendered/content/sandbox/foo.json
rendered: /markdown_record/rendered/content/configuration_fragments.json
rendered: /markdown_record/rendered/content/configuration.json
rendered: /markdown_record/rendered/content/controller_helpers_fragments.json
rendered: /markdown_record/rendered/content/controller_helpers.json
rendered: /markdown_record/rendered/content.html
rendered: /markdown_record/rendered/content/custom_models_and_associations.html
rendered: /markdown_record/rendered/content/erb_syntax_and_view_helpers.html
rendered: /markdown_record/rendered/content/content_frags.html
rendered: /markdown_record/rendered/content/model_basics.html
rendered: /markdown_record/rendered/content/routes.html
rendered: /markdown_record/rendered/content/content_dsl.html
rendered: /markdown_record/rendered/content/rendering_basics.html
rendered: /markdown_record/rendered/content/installation.html
rendered: /markdown_record/rendered/content/home.html
rendered: /markdown_record/rendered/content/sandbox.html
rendered: /markdown_record/rendered/content/sandbox/foo.html
rendered: /markdown_record/rendered/content/configuration.html
rendered: /markdown_record/rendered/content/controller_helpers.html
---------------------------------------------------------------
42 files rendered.
42 files saved.
</code></pre>
      <p>Congratulations! You have installed MarkdownRecord. If you are not viewing this from the host application already, go ahead and start your Rails server and navigate to your <a href="http://localhost:3000/mdr/content/home">local host demo</a> to continue following this guide.</p>
      <!--content/installation-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/installation">content/installation</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "name": "Rendering Basics", "parent_id": "content/home" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   2, "name": "Rendering Basics" } -->
      <h1>Rendering Basics</h1>
      <p>This section will cover the basic concepts of MarkdownRecord.</p>
      <h2>Important Directories</h2>
      <p>MarkdownRecord expects to find a <code>markdown_record</code> directory in your project&#39;s root folder, and by default looks for the following subdirectories inside it:</p>
      <ul>
        <li><code>content</code>: this is where all your original source files will go. When you write a new markdown file, it will live in here.</li>
        <li><code>layouts</code>: this is where the layouts used when rendering your markdown source files to HTML should go. This folder should already have a some layouts that you can customize to your liking.</li>
        <li><code>rendered</code>: this is where all the rendered JSON and HTML files go. You should never have to edit any of the files in here. However, you may want to delete this folder and re-render everything (the folder will be generated again) at certain times, such as when you delete a source file and want to remove the corresponding rendered files and data from your application.</li>
      </ul>
      <h2>Rendering Output</h2>
      <p>By default, MarkdownRecord renders each markdown file in <code>content</code> as both a JSON file and an HTML file in the <code>rendered</code> directory. It also renders each directory into concatenated JSON and an HTML files containing the rendered content of all their contents. The organization and naming of the rendered files should mirror the organization of the source files and directories in <code>content</code>, with the concatenated files at the same level of their respective directories.</p>
      <p>In addition, MarkdownRecord also renders and extra JSON file with the <code>_fragments</code> suffix. This file contains the auto generated data required to populate <code>::MarkdownRecord::ContentFragment</code> models, and is kept separate to keep them from getting mixed in with the JSON rendered from the content files you create.</p>
      <p><em>IMPORTANT: because of the special meaning of the <code>_fragments</code> suffix, the markdown content files that you create should not have <code>_fragments</code> in their name to avoid unexpected problems.</em></p>
      <h2>Numeric Prefixes</h2>
      <p>You will notice that each file and directory for this demo in the <code>content</code> directory has a numeric prefix. These prefixes are how MarkdownRecord determines the order of content in the concatenated files. By using a numeric prefix, the exact order can be specified leading to predictable results.</p>
      <p>By default, MarkdownRecord ignores these numeric prefixes for all other purposes. This means that they should not be included in id values for content fragments or in the <code>content_path</code> parameter when loading rendered content in the browser (more on both these topics will be discussed later in this guide.). Because of this, it is important that the portion of each filename that comes after the numeric prefix be unique within a subdirectory. If two filename only differ in their numeric prefix, there will be a conflit.</p>
      <p>MarkdownRecord can render content using three different strategies: <code>file</code>, <code>directory</code> and <code>full</code>. The default strategy is <code>full</code> and will render all files and directories. The <code>file</code> strategy will render only files and will not concatenate source content for each directory. The <code>directory</code> strategy will only render the concatenated files for each directory.</p>
      <h2>File Extensions</h2>
      <p>MarkdownRecord supports ERB syntax in markdown files that have a <code>.md.erb</code> extension. If you don&#39;t want MarkdownRecord to process your files as ERB templates, they should have the <code>.md</code> extension instead.</p>
      <h2>Thor tasks</h2>
      <p>The MarkdownRecord rendering process is executed via Thor tasks, just like the one used in the installation instructions. The one there looks like this:</p>
      <pre><code class="bash">thor render_content:all -s
</code></pre>
      <p>Note the <code>all</code> part of that command, which indicates that both JSON and HTML will be rendered. You could use <code>json</code> or <code>html</code> there to only render one type of content.</p>
      <p>The <code>-s</code> argument indicates that the rendered content should be saved. If that argument is omitted, you will see the output of the rendering but it will only do a dry run without saving anything.</p>
      <p>You can see more options for the Thor task by running: </p>
      <pre><code class="bash">thor render_content -h 
</code></pre>
      <pre><code class="bash">Commands:
  thor render_content:all             # renders html and json content
  thor render_content:help [COMMAND]  # Describe available commands or one specific command
  thor render_content:html            # renders html content
  thor render_content:json            # renders json content
Options:
  d, [--subdirectory=SUBDIRECTORY]  
  s, [--save], [--no-save]          
  r, [--strat=STRAT]                
  f, [--frag], [--no-frag]   
</code></pre>
      <h3>Validation</h3>
      <p>MarkdownRecord validates your filenames and JSON data before rendering. If it finds any problems, it will output a message to the terminal and nothing will be rendered.</p>
      <!--content/rendering_basics-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/rendering_basics">content/rendering_basics</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "Content DSL" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   3, "name": "Content DSL" } -->
      <h1>Content DSL</h1>
      <p>This section describes the Content DSL MarkdownRecord provides to allow you to define application data right alongside your written markdown content.</p>
      <p>While writing documentation in your markdown source files, you can define json data using HTML comments which will then be made available to you within your application code (if you define matching models), or directly served via built in routes.</p>
      <p>To do this, simply write an HTML comment like this in your markdown files:</p>
      <pre><code class="html">&lt;!--model 
  { 
    &quot;type&quot;: &quot;markdown_record/demo/dsl_command&quot;,
    &quot;id&quot;: 1, 
    &quot;name&quot;: &quot;model&quot;,
    &quot;example_id&quot;: 1
  } 
--&gt;
</code></pre>
      <p><em>Note: you can write these JSON object inline as well to be more concise.</em></p>
      <p>As you can see, all that is required is a JSON object inside a special comment that defines your data. The <code>model</code> part of the comment is a DSL commant that tells MarkdownRecord how to process the comment, and in this case it will take your JSON object and include it in its final renderd JSON output, which will automatically make it available via the provided routes and controllers. If this part is missing or unrecognized, then the comment will be treated as a plain HTML comment and nothing will be done with its contents.</p>
      <p>There are several different DSL commands that you can use to define application data within your markdown source documents. They are as follows:</p>
      <!--model { "type": "markdown_record/demo/dsl_command", "id": 1, "name": "model", "section_id": 3 } -->
      <!--attribute:description:string-->
      <ul>
        <li>
          <p><code>model</code> is the main command that tells MarkdownRecord that you want to define a model or JSON object. The only attribute required in the json object you provide is the <code>type</code> attribute, which is used as an index in the final JSON output (each index points to an array of objects of that type). The type can be whatever you want if you don&#39;t plan on using corresponding Ruby models. If you <em>do</em> plan to use corresponding Ruby models, then the <code>type</code> attribute should match the fully qualified class name of the model in underscore form (i.e. <code>Foo::BarBaz</code> would be <code>foo/bar_baz</code>). </p>
          <p>MarkdownRecord puts each model in a stack structure during rendering, and remembers the order in which models are defined within a single markdown file. This is important, as the next command in this list allows you to add additional attributes where the values are taken from your markdown content itself. The model that attributes get assigned to in this way is always the model at the top of the stack.
          </p>
          <p>See the example above.
          </p>
        </li>
      </ul>
      <!--model { "type": "markdown_record/demo/dsl_command", "id": 2, "name": "attribute", "section_id": 3 } -->
      <!--attribute:description:string-->
      <ul>
        <li>
          <p><code>attribute:&lt;attribute_name&gt;:&lt;type&gt;</code> tells MarkdownRecord that any text that follows should be assigned to the top model on the stack as the value of the given attribute, until it sees the <code>end_attribute</code> command.</p>
          <p>The <code>type</code> part of this command can be <code>html</code>, <code>md</code>, <code>int</code>, <code>float</code>, <code>string</code>, or omitted. MarkdownRecord will process the final value of the attribute differently based on this value. If the type is <code>html</code>, it will be rendered into an html string. If it is <code>md</code>, then it will be left as is and slightly cleaned up to remove leading and trailing white space. If it is <code>int</code> or <code>float</code>, it will be parsed accordingly into an numeric value, and if it is <code>string</code>, it will be stripped of any markdown syntax and all leading and trailing whitespace will be removed. The <code>string</code> option will also cause multiple newlines to be reduced to a single newline. If the type option is omitted, MarkdownRecord will not process the attribute value and it will contain the raw content read from the markdown file.
          </p>
          <p>Example:</p>
          <pre><code class="html">&lt;!--attribute:description:string--&gt;
</code></pre>
          <!--end_model-->
          <!--model { "type": "markdown_record/demo/dsl_command", "id": 3, "name": "end_attribute", "section_id": 3 } -->
          <!--attribute:description:string--></li>
        <li>
          <p><code>end_attribute</code> tells MarkdownRecord to stop assigning text as an attribute value to the top model on the stack. If the top most model is popped before this command is given or the end of the source file is reached, then it implicitly stops assigning text to it.
          </p>
          <p>Example:</p>
          <pre><code class="html">&lt;!--end_attribute--&gt;
</code></pre>
          <!--end_model-->
          <!--model { "type": "markdown_record/demo/dsl_command", "id": 4, "name": "end_model", "section_id": 3 } -->
          <!--attribute:description:string--></li>
        <li>
          <p><code>end_model</code> tells MarkdownRecord to pop the top model of the stack. This command isn&#39;t necessary unless you are defining models in a way that requires you to assign attributes to a model that is no longer the top model on the stack.
          </p>
          <p>Example:</p>
          <pre><code class="html">&lt;!--end_model--&gt;
</code></pre>
          <!--end_model-->
          <!--model { "type": "markdown_record/demo/dsl_command", "id": 5, "name": "fragment", "section_id": 3 } -->
          <!--attribute:description:string--></li>
        <li>
          <p><code>fragment</code> is similar to <code>model</code> in that it expects a JSON object, but the object is assigned to the <code>meta</code> attribute of the <code>ContentFragment</code> corresponding to the current markdown file. As such, this command should only be used once in each file. This command provides a way of attaching custom data to ContentFragments, such as a layout you want to use for rendering from a controller, details about the content&#39;s author, or perhaps who should be able to access it, etc. You can then interact this data in your application code.</p>
          <p>Since content is not just rendered for each individual file, but is also concatenated into rendered files for each directory, the ContentFraments representing these concatenated files will have each file&#39;s fragment meta data as a nested object, indexed by the respective file&#39;s path.
          </p>
          <p>Example:</p>
          <pre><code class="html">&lt;!--fragment { &quot;author&quot;: &quot;Bryant Morrill&quot; } --&gt;
</code></pre>
          <!--end_model-->
          <!--model { "type": "markdown_record/demo/dsl_command", "id": 6, "name": "directory_fragment", "section_id": 3 } -->
          <!--attribute:description:string--></li>
        <li>
          <p><code>directory_fragment</code> is used exactly the same way as <code>fragment</code> but defines the <code>meta</code> attribute of the <code>ContentFragment</code> for the current directory. As such, this should only be used once per directory level, otherwise subsequently defined data might overwrite preceding data.
            &lt;!--model { &quot;type&quot;: &quot;markdown_record/demo/dsl_command&quot;, &quot;id&quot;: 7, &quot;name&quot;: &quot;use_layout&quot;, &quot;section_id&quot;: 3 } --&gt;
          </p>
        </li>
        <li>
          <p><code>use_layout:&lt;path&gt;</code> simply specifies a layout by its relative file path to use when rendering the current markdown file to HTML. This is useful for when you have specific markdown files that you want to render using a different layout than the layout configured for use with all other files.
          </p>
          <p>Example:</p>
          <pre><code class="html">&lt;!--use_layout:_custom_layout.html.erb--&gt;
</code></pre>
          <!--end_model--></li>
      </ul>
      <p>You can view this document&#39;s source files in <code>markdown_record/content</code> to see some of the above DSL commands in use.</p>
      <!--content/content_dsl-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/content_dsl">content/content_dsl</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "Routes" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   4, "name": "Routes" } -->
      <h1>Routes</h1>
      <p>This section discusses the automatically available routes you can use to render markdown content as HTML or JSON.</p>
      <p>If you are reading this document in a browser by rendering it from your application, then you will have already ran the Thor command necessary to render the demo content as HTML and JSON. You can also see the HTML and JSON files in the <code>rendered</code> directory. In fact, the content you are viewing right now as you read this is one of those files, served to you via the built in routes that come with MarkdownRecord.</p>
      <p>All of the following routes should now resolve successfully:</p>
      <ul>
        <li><code>&lt;application root path&gt;/mdr/html/&lt;content_path&gt;</code></li>
        <li><code>&lt;application root path&gt;/mdr/json/&lt;content_path&gt;</code></li>
        <li><code>&lt;application root path&gt;/&lt;content_path&gt;</code></li>
      </ul>
      <p><code>content_path</code> in the above routes is the path to a rendered file or directory (relative to the <code>rendered</code> folder). When you navigate to a path that points to a directory, you will see the concatenated contens of everything that is in that directory.</p>
      <p>The <code>html</code> routes only return HTML, while the <code>json</code> routes only return JSON. The generic route returns either HTML or JSON depending on the ACCEPT header of your request or the extension of the url you are accessing (for example, appending <code>.json</code> at the end of the current url will load all the JSON models defined in this this document&#39;s markdown source files using the Content DSL commands described above).</p>
      <p>In addition to the above routes, routes for downloading content are provided as well. They are:</p>
      <ul>
        <li><code>&lt;application root path&gt;/mdr/html/download/&lt;content_path&gt;</code></li>
        <li><code>&lt;application root path&gt;/mdr/json/download/&lt;content_path&gt;</code></li>
        <li><code>&lt;application root path&gt;/download/&lt;content_path&gt;</code></li>
      </ul>
      <p>The download routes are not enabled by default, but can be enabled if you want to be able to download your rendered content.</p>
      <p>Here is a complete list of links to all the rendered HTML files of this demo (each item has a JSON and an HTML version), all of which use the routes described above:</p>
      - <a href="/mdr/content/custom_models_and_associations">content/custom_models_and_associations</a><br>
      - <a href="/mdr/content/installation">content/installation</a><br>
      - <a href="/mdr/content/model_basics">content/model_basics</a><br>
      - <a href="/mdr/content/routes">content/routes</a><br>
      - <a href="/mdr/content/content_dsl">content/content_dsl</a><br>
      - <a href="/mdr/content/content_frags">content/content_frags</a><br>
      - <a href="/mdr/content/sandbox/foo">content/sandbox/foo</a><br>
      - <a href="/mdr/content/sandbox/sandbox_nested/bar">content/sandbox/sandbox_nested/bar</a><br>
      - <a href="/mdr/content/sandbox/sandbox_nested">content/sandbox/sandbox_nested</a><br>
      - <a href="/mdr/content/sandbox">content/sandbox</a><br>
      - <a href="/mdr/content/configuration">content/configuration</a><br>
      - <a href="/mdr/content/layouts">content/layouts</a><br>
      - <a href="/mdr/content/erb_syntax_and_view_helpers">content/erb_syntax_and_view_helpers</a><br>
      - <a href="/mdr/content/controller_helpers">content/controller_helpers</a><br>
      - <a href="/mdr/content/home">content/home</a><br>
      - <a href="/mdr/content/rendering_basics">content/rendering_basics</a><br>
      - <a href="/mdr/content">content</a><br>
      - <a href="/mdr/html/content/custom_models_and_associations">html/content/custom_models_and_associations</a><br>
      - <a href="/mdr/html/content/installation">html/content/installation</a><br>
      - <a href="/mdr/html/content/model_basics">html/content/model_basics</a><br>
      - <a href="/mdr/html/content/routes">html/content/routes</a><br>
      - <a href="/mdr/html/content/content_dsl">html/content/content_dsl</a><br>
      - <a href="/mdr/html/content/content_frags">html/content/content_frags</a><br>
      - <a href="/mdr/html/content/sandbox/foo">html/content/sandbox/foo</a><br>
      - <a href="/mdr/html/content/sandbox/sandbox_nested/bar">html/content/sandbox/sandbox_nested/bar</a><br>
      - <a href="/mdr/html/content/sandbox/sandbox_nested">html/content/sandbox/sandbox_nested</a><br>
      - <a href="/mdr/html/content/sandbox">html/content/sandbox</a><br>
      - <a href="/mdr/html/content/configuration">html/content/configuration</a><br>
      - <a href="/mdr/html/content/layouts">html/content/layouts</a><br>
      - <a href="/mdr/html/content/erb_syntax_and_view_helpers">html/content/erb_syntax_and_view_helpers</a><br>
      - <a href="/mdr/html/content/controller_helpers">html/content/controller_helpers</a><br>
      - <a href="/mdr/html/content/home">html/content/home</a><br>
      - <a href="/mdr/html/content/rendering_basics">html/content/rendering_basics</a><br>
      - <a href="/mdr/html/content">html/content</a><br>
      - <a href="/mdr/json/content/custom_models_and_associations">json/content/custom_models_and_associations</a><br>
      - <a href="/mdr/json/content/installation">json/content/installation</a><br>
      - <a href="/mdr/json/content/model_basics">json/content/model_basics</a><br>
      - <a href="/mdr/json/content/routes">json/content/routes</a><br>
      - <a href="/mdr/json/content/content_dsl">json/content/content_dsl</a><br>
      - <a href="/mdr/json/content/content_frags">json/content/content_frags</a><br>
      - <a href="/mdr/json/content/sandbox/foo">json/content/sandbox/foo</a><br>
      - <a href="/mdr/json/content/sandbox/sandbox_nested/bar">json/content/sandbox/sandbox_nested/bar</a><br>
      - <a href="/mdr/json/content/sandbox/sandbox_nested">json/content/sandbox/sandbox_nested</a><br>
      - <a href="/mdr/json/content/sandbox">json/content/sandbox</a><br>
      - <a href="/mdr/json/content/configuration">json/content/configuration</a><br>
      - <a href="/mdr/json/content/layouts">json/content/layouts</a><br>
      - <a href="/mdr/json/content/erb_syntax_and_view_helpers">json/content/erb_syntax_and_view_helpers</a><br>
      - <a href="/mdr/json/content/controller_helpers">json/content/controller_helpers</a><br>
      - <a href="/mdr/json/content/home">json/content/home</a><br>
      - <a href="/mdr/json/content/rendering_basics">json/content/rendering_basics</a><br>
      - <a href="/mdr/json/content">json/content</a><br>
      <p>Some of the above routes are the rendered versions of individual files, and some are the concatenated and rendered contents of an entire directory.</p>
      <!--content/routes-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/routes">content/routes</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "Model Basics" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   5, "name": "Model Basics" } -->
      <h1>MarkdownRecord Models</h1>
      <p>The <code>::MarkdownRecord::Base</code> model is the base class for all models used for interacting with the JSON content that is rendered by MarkdownRecord. It has the following attributes:</p>
      <ul>
        <li><code>id</code></li>
        <li><code>type&lt;String&gt;</code></li>
        <li><code>subdirectory&lt;String&gt;</code></li>
        <li><code>filename&lt;String&gt;</code></li>
      </ul>
      <p>The <code>id</code> attribute doesn&#39;t have a type, but for <code>::MarkdownRecord::ContentFragment</code> models it will always be a string value equal to the relative path of the file the model represents. You can set it to any value for the models you define, but each model should have an id that is unique among models of the same type.</p>
      <p>The <code>type</code> attribute is the fully qualified class name of the model in underscore form (i.e. <code>::MarkdownRecord::ContentFragment</code> would be <code>markdown_record/content_fragment</code>).</p>
      <p><code>subdirectory</code> and <code>filename</code> always match the relative path of the file the model was defined in, or in the case of content fragments, the file the model represents. These attributes are auto-populated during the rendering process.</p>
      <h2>Query Methods</h2>
      <p><code>::MarkdownRecord::Base</code> provides several query methods to it&#39;s child classes. They are:</p>
      <ul>
        <li><code>find</code></li>
        <li><code>all</code></li>
        <li><code>where</code></li>
      </ul>
      <p>These methods all work similarly to ActiveRecord by design. For example, if we use the models defined in the previously in this guide, then we could do this:</p>
      <pre><code class="ruby">::MarkdownRecord::Demo::DslCommand.find(4)
 =&gt; #&lt;MarkdownRecord::Demo::DslCommand description: &quot;end_model tells MarkdownRecord to pop the top model of the stack. This command isn&#39;t necessary unless you are defining models in a way that requires you to assign attributes to a model that is no longer the top model on the stack.&quot;, filename: &quot;content_dsl&quot;, id: 4, name: &quot;end_model&quot;, subdirectory: &quot;content/api_docs&quot;, type: &quot;markdown_record/demo/dsl_command&quot;&gt;
</code></pre>
      <p><em>or</em></p>
      <pre><code class="ruby">::MarkdownRecord::Demo::DslCommand.all
 =&gt; 
[#&lt;MarkdownRecord::Demo::DslCommand description: &quot;...&quot;, name: &quot;model&quot;, ...&gt;,
 #&lt;MarkdownRecord::Demo::DslCommand description: &quot;...&quot;, name: &quot;attribute&quot;, ...&gt;
 ...
]
</code></pre>
      <p>The <code>where</code> query method takes an optional hash of filters and returns a <code>MarkdownRecord::Association</code> object, which you can chain additional methods onto. The methods you can chain onto this object are:</p>
      <ul>
        <li><code>where</code>: subsequent calls to this query method will merge the passed filters into the previously provided filter hash.</li>
        <li><code>not</code>: this method takes a hash of filters that is negated, so it will only return models that don&#39;t pass filters.</li>
        <li><code>fragmentize</code>: this method turns the association into a fragment association, meaning it will filter and return <code>MarkdownRecord::ContentFragment</code> models only.</li>
        <li><code>to_fragments</code>: this method queries for MarkdownRecord models but returns their coresponding content fragments instead. This will often result in duplicates due to models being defined in the same file.</li>
        <li><code>all</code>: this method simply returns an Array of models, filtered according to whatever filters have been provided to the association object.</li>
      </ul>
      <p><code>MarkdownRecord::Association</code> also supports the <code>to_a</code>, <code>each</code>, <code>map</code>, <code>count</code>, <code>any?</code>, <code>empty?</code>, <code>first</code>, <code>last</code>, <code>second</code>, <code>third</code> and <code>fourth</code> methods which get executed on the backing Array after loading the data with the most recent filters. For additional functionality, you may call <code>all</code> or <code>to_a</code> to work with the backing Array directly.</p>
      <h2>Filters</h2>
      <p>MarkdownRecord supports various types of filter values. Those types and what they mean are as follows:</p>
      <ul>
        <li><code>Array</code>: the attribute value must be included in the array.</li>
        <li><code>Hash</code>: the attribute value must be a Hash which the filter value (a Hash of nested filters) will be applied against.</li>
        <li><code>nil</code>: the attribute value must be nil/null.</li>
        <li><code>Regexp</code>: the attribute value must match the Regex expression.</li>
        <li><code>:not_null</code>: the attribute value must not be nil/null.</li>
        <li><code>:null</code>: the attribute value must be nil/null.</li>
        <li>Any other valid JSON type, in which case the attribute value must equal the filter value.</li>
      </ul>
      <p>In addition, you can pass <code>:__and__</code> or <code>:__or__</code> as filter keys that point to arrays of filter hashes. In the former case, all filter hashes must pass, and in the later case, only one of the filter hases mus pass.</p>
      <p>Finally, you can pass <code>:__not__</code> as a filter key as well, which should point to a filter hash where all the filters must not pass.</p>
      <p>Examples:</p>
      <pre><code class="ruby"># querying with a string value
MarkdownRecord::Demo::DslCommand.where(:name =&gt; &quot;model&quot;).all
 =&gt; [#&lt;MarkdownRecord::Demo::DslCommand ...&gt;]
</code></pre>
      <pre><code class="ruby"># querying for models that don&#39;t have &quot;fragment&quot; in the name.
MarkdownRecord::Demo::DslCommand.where(__not__: { :name =&gt; /fragment/}).map(&amp;:name)
 =&gt; [&quot;model&quot;, &quot;attribute&quot;, &quot;end_attribute&quot;, &quot;end_model&quot;, &quot;use_layout&quot;]
</code></pre>
      <pre><code class="ruby">MarkdownRecord::Demo::DslCommand.where(__or__: [{ :name =&gt; /fragment/}, {:name =&gt; :null}]).map(&amp;:name)
 =&gt; [&quot;model&quot;, &quot;fragment&quot;, &quot;directory_fragment&quot;]
</code></pre>
      <pre><code class="ruby">MarkdownRecord::ContentFragment.where(:meta =&gt; {:author =&gt; &quot;Bryant Morrill&quot;}).first
 =&gt; #&lt;MarkdownRecord::ContentFragment ...&gt;
</code></pre>
      <h2>Automatic Associations</h2>
      <p><code>::MarkdownRecord::Base</code> provides several associations automatically to its child classes, which are all based on their relative relative location to each other. These associations are:</p>
      <ul>
        <li><code>siblings</code>: all models generated from files in the same directory and at the same level as the current model.</li>
        <li><code>class_siblings</code>: same as <code>siblings</code> but only models of the same type.</li>
        <li><code>children</code>: all models generated from files in nested directories within the directory the current model is defined in.</li>
        <li><code>fragment</code>: the <code>MarkdownRecord::ContentFragment</code> instance representing the file where the model was defined.</li>
      </ul>
      <p><code>siblings</code>, <code>class_siblings</code> and <code>children</code> are all methods that return a <code>MarkdownRecord::Association</code> object. The <code>fragment</code> method returns a <code>MarkdownRecord::ContentFragment</code> instance.</p>
      <!--content/model_basics-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/model_basics">content/model_basics</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "Content Fragments" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   6, "name": "Content Fragments" } -->
      <h1>Content Fragments</h1>
      <p>This section describes how to use the <code>::MarkdownRecord::ContentFragment</code> model to easily interact with your written markdown content from your application code.</p>
      <p>Each file and directory in the <code>content</code> directory that gets rendered as either HTML or JSON will have a content fragment JSON object created for it that represents that source file. These JSON objects get stored in the corresponding file with a <code>_fragments</code> suffix.</p>
      <p>In your application code, you can interact with content fragment JSON objects via the <code>::MarkdownRecord::ContentFragment</code> model. This model is a child class of <code>::MarkdownRecord::Base</code> and adds the following attributes:</p>
      <ul>
        <li><code>meta&lt;Hash&gt;</code></li>
        <li><code>concatenated&lt;Boolean&gt;</code></li>
      </ul>
      <p>The <code>meta</code> attribute contains a <code>Hash</code> populated with any data you that you defined using the <code>fragment</code> or <code>directory_fragment</code> content DSL methods.</p>
      <p><code>concatentated</code> will be auto-populated during rendering and will be true for fragments representing a directory, and false for those representing files.</p>
      <h3>Querying Content Fragments</h3>
      <p>You can query content fragmets just like you query other MarkdownRecord models, but these queries will only return content fragments. Using filter values that are Hashes, howevers, will allow you to query and filter content fragments based on their <code>meta</code> attribute.</p>
      <h2>Associations</h2>
      <p>Content fragments also have a few extra associations, which are:</p>
      <ul>
        <li><code>ancestors</code>: the content fragments above the current fragment in the content structure.</li>
        <li><code>ancestors_from</code>: the content fragments above the current fragment in the content structure, starting with a content fragment or content fragment id that is passed in.</li>
        <li><code>parent</code>: the content fragment directly above the current fragment in the content structure.</li>
      </ul>
      <p>Each of the above associations use the file tree structure, meaning that they will only return content fragments representing directories.</p>
      <p>The <code>parent</code> method, however, can have its behavior overridden by setting a <code>parent_id</code> field in the <code>meta</code> hash of the content fragment to the id of another content fragment using the Content DSL.</p>
      <p>For example, the file that this text is written in is at <code>content/blog/content_frags.md</code>, meaning that the parent of the directory level content fragment with <code>id = &quot;content/blog&quot;</code> would normally be the directory level content fragment with <code>id = &quot;content&quot;</code>.</p>
      <p>In code, this would look like:</p>
      <pre><code class="ruby">MarkdownRecord::ContentFragment.find(&quot;content/content_frags&quot;).parent
 =&gt; #&lt;MarkdownRecord::ContentFragment concatenated: true, filename: &quot;content&quot;, id: &quot;content&quot;, meta: {&quot;name&quot;=&gt;&quot;Demo&quot;, ...}, subdirectory: &quot;&quot;, type: &quot;markdown_record/content_fragment&quot;&gt; 
</code></pre>
      <p>But one of the files in in <code>content/blog</code> uses the Content DSL to define meta data for the directory content fragment, like so:</p>
      <pre><code class="html">&lt;!--directory_fragment { &quot;name&quot;: &quot;Example: Blog&quot;, &quot;parent_id&quot;: &quot;content/home&quot; } --&gt;
</code></pre>
      <p>The <code>parent_id</code> in the <code>meta</code> hash overrides the default behavior, which changes what fragment is returned from <code>parent</code>:</p>
      <pre><code class="ruby">MarkdownRecord::ContentFragment.find(&quot;content/content_frags&quot;).parent
 =&gt; #&lt;MarkdownRecord::ContentFragment concatenated: false, filename: &quot;home&quot;, id: &quot;content/home&quot;, meta: {&quot;name&quot;=&gt;&quot;Home&quot;, ...}, subdirectory: &quot;content&quot;, type: &quot;markdown_record/content_fragment&quot;&gt;
</code></pre>
      <p>The ability to overried the natural <code>parent</code> of a content fragment is useful for constructing a list or hierarchy of content that is not strictly based on file structure. The <code>parents_from</code> method is useful in doing this, as it builds a hierarchy but respect any <code>parent_id</code> of the content fragments it comes across instead of assuming the containing directory is the parent. This is useful for constructing breadcrumbs and navigation in your views.</p>
      <p>Exampe:</p>
      <pre><code class="ruby">MarkdownRecord::ContentFragment.find(&quot;content/sandbox/foo&quot;)
  .parents_from(&quot;content/home&quot;)
  .map(&amp;:id)
 =&gt; [&quot;content/home&quot;, &quot;content/sandbox&quot;]
</code></pre>
      <h2>Instance Methods</h2>
      <p><code>MarkdownRecord::ContentFragment</code> has the following instance methods:</p>
      <ul>
        <li><code>exists?</code>: returns <code>true</code><code>or</code>false`<code>depending on whether a JSON or HTML file corresponding to the content fragment can be found. This should always return</code>true` unless something has gone wrong with the rendering process.</li>
        <li><code>json_exists?</code>: returns <code>true</code> if a corresponding JSON files can be found.</li>
        <li><code>html_exists?</code>: returns <code>true</code> if a corresponding HTML files can be found.</li>
        <li><code>read_json</code>: reads the corresponding JSON file.</li>
        <li><code>read_html</code>: reads the corresponding HTML file.</li>
        <li><code>json_path</code>: returns the path to the corresponding JSON file.</li>
        <li><code>html_path</code>: returns the path to the corresponding HTML file.</li>
      </ul>
      <!--content/content_frags-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/content_frags">content/content_frags</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "ERB Syntax and View Helpers" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   7, "name": "ERB Syntax and View Helpers" } -->
      <h1>ERB Syntax and View Helpers</h1>
      <p>This section describes how to use ERB syntax and view helpers in your markdown files and ERB views in conjunction with MarkdownRecord models to make navigating across all your rendered content easy.</p>
      <h2>ERB Syntax</h2>
      <p>MarkdownRecord supports the use of ERB syntax in your markdown source files. It also provides the following local variables for use in your ERB code:</p>
      <ul>
        <li><code>filename</code>: the name of the file being rendered.</li>
        <li><code>subdirectory</code>: the subdirectory of the file being rendered.</li>
        <li><code>frag_id</code>: the id of the fragment corresponding to the file being rendered.</li>
        <li><code>fragment</code>: the content fragment model instance corresponding to the file being rendered.</li>
      </ul>
      <h2>Rails View Helpers</h2>
      <p>All the standard view helpers that come with Rails should be accessible within your markdown source files when rendered as ERB files, such as tag helpers and path helpers.</p>
      <p>For example, the image below is rendered using the <code>image_tag</code> tag helper:</p>
      <img src="/assets/ruby-logo-f7e5cfd4f5b7652bada815c4c5336faccb05c8d37b95decec01747f459bba450.png" />
      <h2>View Helpers</h2>
      <p>MarkdownRecord provides the following view helpers to use in your ERB views as well as in your markdown content source files:</p>
      <ul>
        <li>
          <p><code>link_to_markdown_record</code>: generates a link to the content fragment you pass in, or else the content fragment corresponding to the MarkdownRecord model you pass in.</p>
          <p>For example, for a content fragment such as:</p>
          <pre><code class="ruby">fragment
=&gt; #&lt;MarkdownRecord::ContentFragment filename: &quot;content&quot;, id: &quot;content/erb_syntax_and_view_helpers&quot;, meta: {&quot;name&quot;=&gt;&quot;ERB Syntax and View Helpers&quot;, ...}, ...&gt; 
</code></pre>
          <p>When you pass it into the view helper like so:</p>
          <pre><code class="html"><%%= link_to_markdown_record(fragment)%>
</code></pre>
          <p>The result would be the following markup:</p>
          <pre><code class="html">&lt;a href=&quot;/mdr/content/erb_syntax_and_view_helpers&quot;&gt;ERB Syntax and View Helpers&lt;/a&gt;
</code></pre>
          <p>Notice how the text in the link is the name value found in the content fragment meta attribute. This is because MarkdownRecord checks to see if the model passed in responds to <code>name</code>, and <code>MarkdownRecord::ContentFragment</code> has a <code>name</code> method that returns the <code>name</code> field, if present, from its meta hash.</p>
          <p>A fragment without a name will be rendered like this:</p>
          <pre><code class="html">&lt;a href=&quot;/mdr/content/erb_syntax_and_view_helpers&quot;&gt;/mdr/content/blog/view_helpers&lt;/a&gt;
</code></pre>
          <p>Unless you pass in a name explicitly:</p>
          <pre><code class="html"><%%= link_to_markdown_record(fragment, "Click Here!") %>
</code></pre>
          <p>Which will produce:</p>
          <pre><code class="html">&lt;a href=&quot;/mdr/content/erb_syntax_and_view_helpers&quot;&gt;Click Here!&lt;/a&gt;
</code></pre>
          <p>You may have noticed that this view helper works almost identically to the standard Rails <code>link_to</code> method, and in fact this helper simply wraps <code>link_to</code>. As such, it has the same API that accepts <code>html_options</code> and a <code>block</code> as well. The only difference is that you have to pass in a <code>MarkdownRecord</code> model as the first parameter.</p>
        </li>
        <li>
          <p><code>link_to_markdown_record_html</code>: this view helper works identically to <code>link_to_markdown_record</code>, but adds the <code>html</code> prefix to the route so that it can only return HTML.</p>
        </li>
        <li>
          <p><code>link_to_download_markdown_record_html</code>: same as <code>link_to_markdown_record_html</code> but downloads a file instead.</p>
        </li>
        <li>
          <p><code>link_to_markdown_record_json</code>: this view helper works identically to <code>link_to_markdown_record</code>, but adds the <code>json</code> prefix to the route so that it can only return HTML.</p>
        </li>
        <li>
          <p><code>link_to_download_markdown_record_html</code>: same as <code>link_to_markdown_record_json</code> but downloads a file instead.</p>
        </li>
      </ul>
      <h3>Breadcrumbs</h3>
      <p>Using the view helpers in conjuction with content fragments, you can easily build navigations that automatically updates when you rerender your content. This guide uses this technique and you can find the following code in the <code>_global_layout.html.erb</code> layout:</p>
      <pre><code class="html"><%% fragment.parents_from("content/home").each_with_index do |frag, index| %>
    <%% unless index == 0%>
        &lt;span class=&quot;breadcrumb_divider&quot;&gt;/&lt;/span&gt;
    <%% end %>
    &lt;li&gt;<%%= link_to_markdown_record(frag)%>
<%% end %>
</code></pre>
      <!--content/erb_syntax_and_view_helpers-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/erb_syntax_and_view_helpers">content/erb_syntax_and_view_helpers</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "Layouts" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   8, "name": "Layouts" } -->
      <h1>Layouts</h1>
      <p>When MarkdownRecord renders markdown source files, it looks for three different ERB layouts that it can use as templates. These layouts are each passed the same local variables as a markdown file when rendered as ERB (as discussed in the previous section), as well as an <code>html</code> variable that is the rendered html produced from the markdown content.</p>
      <p>The layouts that MarkdownRecord uses by default are added to your application at the time of install in the <code>markdown_record/layouts</code> directory. They are:</p>
      <ul>
        <li><code>_file_layout.html.erb</code>: this is the layout used for individual files. Concatenated files will show this layout multiple times, each with a different file rendered in it. The red border of this guide is part of this layout.</li>
        <li><code>_concatenated_layout.html.erb</code>: this is the layout used only for concatenated files. It will only be rendered once per file, but not for files that don&#39;t contain the concatenated contents of a directory. Some of the pages of this guide have a blue border, which is a style defined only in this layout.</li>
        <li><code>_global_layout.html.erb</code>: this is the layout that is used for every rendered file, regardless of whether it is a concatenated file or not. This is the recommended layout to use for global styles, etc.</li>
      </ul>
      <p>In addition to the above, there is also a <code>_custom_layout.html.erb</code> which is used for the contents of the <a href="/mdr/content/sandbox">sandbox</a> part of this guide. This demonstrates how you can override the layout used for a specific file using the <code>user_layout</code> Content DSL command.</p>
      <!--content/layouts-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/layouts">content/layouts</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "Custom Models and Associations" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   8, "name": "Custom Models and Associations" } -->
      <h1>Custom Models and Associations</h1>
      <p>This sectional will discuss how to create MarkdownContent models and defines associations on them, as well as how to define associations between MarkdownContent and ActiveRecord models.</p>
      <p>To make a MarkdownContent, it only needs to inherit from <code>MarkdownContent::Base</code>. Once you have done that, you can define attributes and associations on it to other MarkdownContent models.</p>
      <h2>Attributes</h2>
      <p><code>MarkdownContent::Base</code> includes <code>ActiveAttr::Model</code> to provide attribute functionality. Please see how to use the ActiveAttr gem&#39;s interface <a href="https://github.com/cgriego/active_attr">here</a>.</p>
      <h2>Asscociations</h2>
      <p>You can define custom associations on your model using the <code>belongs_to_content</code>, <code>has_one_content</code> and <code>has_many_content</code> methods like so:</p>
      <pre><code class="ruby">module MarkdownRecord
  module Demo
    class Section &lt; ::MarkdownRecord::Base
      attribute :name
      has_many_content :dsl_commands
    end
  end
end
</code></pre>
      <pre><code class="ruby">module MarkdownRecord
  module Demo
    class DslCommand &lt; ::MarkdownRecord::Base
      attribute :name
      attribute :description
      belongs_to_content :section
    end
  end
end
</code></pre>
      <p>Once the associations are defined, you will want to make sure your JSON objects in your markdown have the required fields. For the example above, the DslCommand model will automatically be given a <code>section_id</code> field that will need to be populated in your markdown like so:</p>
      <pre><code class="html">&lt;!--model { &quot;type&quot;: &quot;markdown_record/demo/dsl_command&quot;, &quot;id&quot;: 6, &quot;name&quot;: &quot;directory_fragment&quot;, &quot;section_id&quot;: 1 } --&gt;
</code></pre>
      <p>Then you can use the association in your code just like ActiveRecord associtions:</p>
      <pre><code class="ruby">MarkdownRecord::Demo::Section.find(3).dsl_commands.all
 =&gt; 
[#&lt;MarkdownRecord::Demo::DslCommand section_id: 1, description: &quot;...&quot;, ...&gt;, ...]
</code></pre>
      <pre><code class="ruby">MarkdownRecord::Demo::DslCommand.find(1).section
 =&gt; #&lt;MarkdownRecord::Demo::Section filename: &quot;content_dsl&quot;, id: 3, name: &quot;Content DSL&quot;, subdirectory: &quot;content&quot;, type: &quot;markdown_record/demo/section&quot;&gt;
</code></pre>
      <p><code>has_many_content</code> will define a method that returns an <code>MarkdownRecord::Association</code> object, which you can then chain queries onto. <code>belongs_to_content</code>  and <code>has_one_content</code> will define methods that returns a single MarkdownContent model.</p>
      <h3>Associations on ActiveRecord Models</h3>
      <p>You can easily integrate MarkdownRecord and ActiveRecord models together using the <code>MarkdownRecord::ContentAssociations</code> module. Just include it in your ActiveRecord model like so:</p>
      <pre><code class="ruby">class Product &lt; ActiveRecord::Base
  include MarkdownRecord::ContentAssociations
  has_one_content :user_manual
  has_many_content :research_notes
end
</code></pre>
      <p>You can define the same associations as described for MarkdownRecord models for ActiveRecord models. An important difference between the two cases, however, is that there are no foreign keys on the MarkdownRecord models that point to ActiveRecord models. Instead, MarkdownRecord expects to find an attribute on the ActiveRecord model that can be used for querying the MarkdownRecord models. For example, the <code>Product</code> model above should have a <code>user_manual_id</code> column or attribute. This effectively makes <code>has_one_content</code> and <code>belongs_to_content</code> aliases for each other. In the case of <code>has_many_content</code>, the model should have an attribute that is a JSON array of ids that point to the related MarkdownRecord models. In the example above, it would be called <code>research_note_ids</code>.</p>
      <!--content/custom_models_and_associations-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/custom_models_and_associations">content/custom_models_and_associations</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "Controller Helpers" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   9, "name": "Controller Helpers" } -->
      <h1>Controller Helpers</h1>
      <p>This section describes the controller helpers provided by MarkdownRecord to help interact with MarkdownRecord.</p>
      <p>To use controller helpers in a controller, simply include the <code>MarkdownRecord::ControllerHelpers</code> module like so:</p>
      <pre><code class="ruby">include ::MarkdownRecord::ControllerHelpers
</code></pre>
      <p>When the module is included, you will be able to call the following methods in your controller:</p>
      <ul>
        <li><code>content_fragment</code>: finds a content fragment based on a passed id. If no id is passed it looks for <code>params[:content_path]</code> instead.</li>
        <li><code>render_html</code>: takes an optional content fragment and an optional layout, then renders the fragment as HTML. If no fragment is provided, it calls <code>content_fragment</code> to get it using <code>params[:content_path]</code>. If no layout is provided, it uses the public_layout configured for MarkdownRecord (by default this is the application layout).</li>
        <li><code>render_json</code>: takes an optional content fragment and renders it as JSON. If no fragment is provided, it calls <code>content_fragment</code> to get it using <code>params[:content_path]</code>.</li>
        <li><code>download_html</code>: same a <code>render_html</code> but renders a file for download.</li>
        <li><code>download_json</code>: same a <code>render_json</code> but renders a file for download.</li>
      </ul>
      <!--content/controller_helpers-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/controller_helpers">content/controller_helpers</a></em></p>
    </div>
    <style>
      .file {
        padding: 10px;
        border: 1px solid #cc4400;
        margin-bottom: 10px;
      }
    </style>
    <div class="file">
      <!--fragment { "author": "Bryant Morrill", "parent_id": "content/home", "name": "Configuration" } -->
      <!--model { "type": "markdown_record/demo/section", "id":   9, "name": "Configuration" } -->
      <h1>Configuration</h1>
      <p>Much of MarkdownRecord&#39;s behavior is configurable. This section covers what can be configured.</p>
      <p>You can configure <code>MarkdownRecord</code> in the initializer that is generated upon installation. The config attributes available are:</p>
      <ul>
        <li><code>content_root</code>: the path to the directory containing your markdown source files. This is <code>markdown_record/content</code> inside your application root by default.</li>
        <li><code>rendered_content_root</code>: the path to the directory where rendered content will be saves. This is <code>markdown_record/rendered</code> inside your application root by default.</li>
        <li><code>layout_directory</code>: the path to the directory containing the layouts used durring rendering. This is <code>markdown_record/layouts</code> inside your application root by default.</li>
        <li><code>concatenated_layout_path</code>: the relative path (from <code>layout_directory</code>) to the layout that should be used for files rendered from the concatenated contents of a directory.</li>
        <li><code>file_layout_path</code>: the relative path (from <code>layout_directory</code>) to the layout that should be used for files rendered from a single markdown source file.</li>
        <li><code>global_layout_path</code>: the relative path (from <code>layout_directory</code>) to the layout that should be used for all rendered files.</li>
        <li><code>markdown_extensions</code>: MarkdownRecord uses the <code>Redcarpet</code> gem under the hood to process markdown. This value is the configuration that gets passed to <code>::Redcarpet::Markdown</code>. The default value is <code>{:fenced_code_blocks =&gt; true, :disable_indented_code_blocks =&gt; true, :no_intra_emphasis =&gt; true}</code>. Please see <a href="https://github.com/vmg/redcarpet">Redcarpet&#39;s documentation</a> for more details.</li>
        <li><code>html_render_options</code>: the <code>render_options</code> that get passed to Redcarpet&#39;s <code>Redcarpet::Render::HTML</code> class. The default value is an empty Hash. Please see <a href="https://github.com/vmg/redcarpet">Redcarpet&#39;s documentation</a> for more details.</li>
        <li><code>public_layout</code>: the path to the layout (from the application root) that should be used when the controllers provided by MarkdownRecord render HTML. The default value is &quot;layouts/application&quot;.</li>
        <li><code>render_strategy</code>: the render strategy that should be use when running the <code>render_content</code> Thor task. The default value is <code>:full</code> but it can be changed to <code>:directory</code> of <code>:file</code>. If the <code>:file</code> strategy is used then MarkdownRecord will render your markdown content each time MarkdownRecord models queries are executed.</li>
        <li><code>html_routes</code>: the routes that are generated to render only HTML. This value is an array of symbols that can include <code>:show</code> and <code>:download</code>. By default the value is <code>[:show]</code>.</li>
        <li><code>json_routes</code>: the routes that are generated to render only JSON. This value is an array of symbols that can include <code>:show</code> and <code>:download</code>. By default the value is <code>[:show]</code>.</li>
        <li><code>content_routes</code>: the routes that are generated to render either HTML or JSON depending on the request. This value is an array of symbols that can include <code>:show</code> and <code>:download</code>. By default the value is <code>[:show]</code>.</li>
        <li><code>mount_path</code>: the path where the MarkdownRecord engine is mounted inside the host application. It is <code>mdr</code> by default.</li>
        <li><code>render_content_fragment_json</code>: a boolean value that determines whether MarkdownRecord renders content fragments and saves them to the <code>rendered_content_root</code> in JSON files with the <code>_fragments</code> suffix. If this is set to <code>false</code>, then MarkdownRecord will render your markdown content each time MarkdownRecord models queries are executed. This is set to <code>true</code> by default.</li>
        <li><code>render_controller</code>: the controller used to render ERB content during the rendering process. If this isn&#39;t set, then the host application&#39;s <code>ApplicationController</code> will be used. By default this is <code>nil</code>.</li>
        <li><code>ignore_numeric_prefix</code>: configurew whether or not MarkdownRecord ignores the numeric prefixes of filenames. The default value is <code>true</code>. When it is set to <code>false</code>, the numeric prefixes will be included in the <code>filename</code> attribute of models, the <code>id</code> attribute of content fragments, and the <code>content_path</code> parameter of requests to the routes for rendered content.</li>
      </ul>
      <!--content/configuration-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/configuration">content/configuration</a></em></p>
    </div>
    <style>
      .custom_layout_file {
        padding: 10px;
        border: 1px solid pink;
        margin-bottom: 10px;
      }
    </style>
    <div class="custom_layout_file">
      <h3>Rendered Using a Custom Layout</h3>
      <!--directory_fragment { "author": "You", "name": "Sandbox", "parent_id": "content/home" } -->
      <!--use_layout:_custom_layout.html.erb-->
      <p>Feel free to use this directory as a sandbox to experiment with the things you learn from the guide, without fear of messing up the guide itself. The things defined here are used for automated tests only, so feel free to  delete/alter anything you want here.</p>
      <p>When you are done experimenting and want to start creating for real, feel free to delete the entire guids and use the online hosted version for reference going forward.</p>
      <p><em>Note: you will need to add the .erb extension to this file to use ERB syntax in it.</em></p>
      <!--model { "id": 1, "type": "markdown_record/tests/model", "string_field": "foo", "int_field": 100, "float_field": 95.5, "bool_field": true, "date_field": "03/13/2023", "maybe_field": null, "hash_field": {} }-->
      <!--model { "id": 2, "type": "markdown_record/tests/model", "string_field": "bar", "int_field": 42, "float_field": 99.9, "bool_field": false, "date_field": "12/25/2020", "maybe_field": 50, "hash_field": { "some_data": { "some_field": 999 }}  }-->
      <!--content/sandbox/foo-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/sandbox/foo">content/sandbox/foo</a></em></p>
    </div>
    <style>
      .custom_layout_file {
        padding: 10px;
        border: 1px solid pink;
        margin-bottom: 10px;
      }
    </style>
    <div class="custom_layout_file">
      <h3>Rendered Using a Custom Layout</h3>
      <!--directory_fragment { "author": "You", "name": "Sandbox", "parent_id": "content/sandbox/foo" } -->
      <!--use_layout:_custom_layout.html.erb-->
      <p>Feel free to use this directory as a sandbox to experiment with the things you learn from the guide, without fear of messing up the guide itself. The things defined here are used for automated tests only, so feel free to  delete/alter anything you want here.</p>
      <p>When you are done experimenting and want to start creating for real, feel free to delete the entire guids and use the online hosted version for reference going forward.</p>
      <p><em>Note: you will need to add the .erb extension to this file to use ERB syntax in it.</em></p>
      <!--model { "id": 1, "type": "markdown_record/tests/child_model", "model_id": 1, "string_field": "hey", "int_field": 100, "float_field": 95.5, "bool_field": true, "date_field": "03/13/2023", "maybe_field": null, "hash_field": {} }-->
      <!--model { "id": 2, "type": "markdown_record/tests/child_model", "model_id": 1, "string_field": "asdf", "int_field": 333, "float_field": 10.5, "bool_field": false, "date_field": "01/01/2000", "maybe_field": 7, "hash_field": {} }-->
      <!--model { "id": 3, "type": "markdown_record/tests/child_model", "model_id": 2, "string_field": "qwert", "int_field": 42, "float_field": 1776, "bool_field": true, "date_field": "09/11/2001", "maybe_field": null, "hash_field": { "some_data": { "some_field": 555 }}  }-->
      <!--model { "id": 4, "type": "markdown_record/tests/child_model", "model_id": 2, "string_field": "ho", "int_field": 42, "float_field": 99.9, "bool_field": false, "date_field": "12/25/2020", "maybe_field": 50, "hash_field": { "some_data": { "some_field": 999 }}  }-->
      <!--model { "id": 1, "type": "markdown_record/tests/other_child_model", "model_id": 2, "string_field": "ho", "int_field": 42, "float_field": 99.9, "bool_field": false, "date_field": "12/25/2020", "maybe_field": 50, "hash_field": { "some_data": { "some_field": 999 }}  }-->
      <!--content/sandbox/sandbox_nested/bar-->
      <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content/sandbox/sandbox_nested/bar">content/sandbox/sandbox_nested/bar</a></em></p>
    </div>
    <!--/content-->
    <p class="rendered_at"><em>The above content was rendered from source files at: <a href="/mdr/content">content</a></em></p>
  </div>
  <!--/content-->
  <div class="navigation">
    <ul>
      <li>Breadcrumbs: </li>
      <li><a href="/mdr/content">Demo</a></li>
    </ul>
  </div>
</div>