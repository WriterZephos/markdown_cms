{"markdown_record/demo/section":[{"type":"markdown_record/demo/section","id":1,"name":"Installation","subdirectory":"content","filename":"installation"},{"type":"markdown_record/demo/section","id":5,"name":"Model Basics","subdirectory":"content","filename":"model_basics"},{"type":"markdown_record/demo/section","id":4,"name":"Routes","subdirectory":"content","filename":"routes"},{"type":"markdown_record/demo/section","id":3,"name":"Content DSL","subdirectory":"content","filename":"content_dsl"},{"type":"markdown_record/demo/section","id":2,"name":"Rendering Basics","subdirectory":"content","filename":"rendering_basics"}],"markdown_record/demo/dsl_command":[{"type":"markdown_record/demo/dsl_command","id":1,"name":"model","section_id":3,"subdirectory":"content","filename":"content_dsl","description":"model is the main command that tells MarkdownRecord that you want to define a model or JSON object. The only attribute required in the json object you provide is the type attribute, which is used as an index in the final JSON output (each index points to an array of objects of that type). The type can be whatever you want if you don't plan on using corresponding Ruby models. If you do plan to use corresponding Ruby models, then the type attribute should match the fully qualified class name of the model in underscore form (i.e. Foo::BarBaz would be foo/bar_baz). \nMarkdownRecord puts each model in a stack structure during rendering, and remembers the order in which models are defined within a single markdown file. This is important, as the next command in this list allows you to add additional attributes where the values are taken from your markdown content itself. The model that attributes get assigned to in this way is always the model at the top of the stack."},{"type":"markdown_record/demo/dsl_command","id":2,"name":"attribute","section_id":3,"subdirectory":"content","filename":"content_dsl","description":"attribute:\u003cattribute_name\u003e:\u003ctype\u003e tells MarkdownRecord that any text that follows should be assigned to the top model on the stack as the value of the given attribute, until it sees the end_attribute command.\nThe type part of this command can be html, md, int, float, string, or omitted. MarkdownRecord will process the final value of the attribute differently based on this value. If the type is html, it will be rendered into an html string. If it is md, then it will be left as is and slightly cleaned up to remove leading and trailing white space. If it is int or float, it will be parsed accordingly into an numeric value, and if it is string, it will be stripped of any markdown syntax and all leading and trailing whitespace will be removed. The string option will also cause multiple newlines to be reduced to a single newline. If the type option is omitted, MarkdownRecord will not process the attribute value and it will contain the raw content read from the markdown file."},{"type":"markdown_record/demo/dsl_command","id":3,"name":"end_attribute","section_id":3,"subdirectory":"content","filename":"content_dsl","description":"end_attribute tells MarkdownRecord to stop assigning text as an attribute value to the top model on the stack. If the top most model is popped before this command is given or the end of the source file is reached, then it implicitly stops assigning text to it."},{"type":"markdown_record/demo/dsl_command","id":4,"name":"end_model","section_id":3,"subdirectory":"content","filename":"content_dsl","description":"end_model tells MarkdownRecord to pop the top model of the stack. This command isn't necessary unless you are defining models in a way that requires you to assign attributes to a model that is no longer the top model on the stack."},{"type":"markdown_record/demo/dsl_command","id":5,"name":"fragment","section_id":3,"subdirectory":"content","filename":"content_dsl","description":"fragment is similar to model in that it expects a JSON object, but the object is assigned to the meta attribute of the ContentFragment corresponding to the current markdown file. As such, this command should only be used once in each file. This command provides a way of attaching custom data to ContentFragments, such as a layout you want to use for rendering from a controller, details about the content's author, or perhaps who should be able to access it, etc. You can then interact this data in your application code.\nSince content is not just rendered for each individual file, but is also concatenated into rendered files for each directory, the ContentFraments representing these concatenated files will have each file's fragment meta data as a nested object, indexed by the respective file's path."},{"type":"markdown_record/demo/dsl_command","id":6,"name":"directory_fragment","section_id":3,"subdirectory":"content","filename":"content_dsl","description":"directory_fragment is used exactly the same way as fragment but defines the meta attribute of the ContentFragment for the current directory. As such, this should only be used once per directory level, otherwise subsequently defined data might overwrite preceding data."},{"type":"markdown_record/demo/dsl_command","id":7,"name":"use_layout","section_id":3,"subdirectory":"content","filename":"content_dsl","description":"use_layout:\u003cpath\u003e simply specifies a layout by its relative file path to use when rendering the current markdown file to HTML. This is useful for when you have specific markdown files that you want to render using a different layout than the layout configured for use with all other files."}],"markdown_record/tests/model":[{"id":1,"type":"markdown_record/tests/model","string_field":"foo","int_field":100,"float_field":95.5,"bool_field":true,"date_field":"03/13/2023","maybe_field":null,"hash_field":{},"subdirectory":"content/sandbox","filename":"foo"},{"id":2,"type":"markdown_record/tests/model","string_field":"bar","int_field":42,"float_field":99.9,"bool_field":false,"date_field":"12/25/2020","maybe_field":50,"hash_field":{"some_data":{"some_field":999}},"subdirectory":"content/sandbox","filename":"foo"}],"markdown_record/tests/child_model":[{"id":1,"type":"markdown_record/tests/child_model","model_id":1,"string_field":"hey","int_field":100,"float_field":95.5,"bool_field":true,"date_field":"03/13/2023","maybe_field":null,"hash_field":{},"subdirectory":"content/sandbox/sandbox_nested","filename":"bar"},{"id":2,"type":"markdown_record/tests/child_model","model_id":1,"string_field":"asdf","int_field":333,"float_field":10.5,"bool_field":false,"date_field":"01/01/2000","maybe_field":7,"hash_field":{},"subdirectory":"content/sandbox/sandbox_nested","filename":"bar"},{"id":3,"type":"markdown_record/tests/child_model","model_id":2,"string_field":"qwert","int_field":42,"float_field":1776,"bool_field":true,"date_field":"09/11/2001","maybe_field":null,"hash_field":{"some_data":{"some_field":555}},"subdirectory":"content/sandbox/sandbox_nested","filename":"bar"},{"id":4,"type":"markdown_record/tests/child_model","model_id":2,"string_field":"ho","int_field":42,"float_field":99.9,"bool_field":false,"date_field":"12/25/2020","maybe_field":50,"hash_field":{"some_data":{"some_field":999}},"subdirectory":"content/sandbox/sandbox_nested","filename":"bar"}],"markdown_record/tests/other_child_model":[{"id":1,"type":"markdown_record/tests/other_child_model","model_id":2,"string_field":"ho","int_field":42,"float_field":99.9,"bool_field":false,"date_field":"12/25/2020","maybe_field":50,"hash_field":{"some_data":{"some_field":999}},"subdirectory":"content/sandbox/sandbox_nested","filename":"bar"}]}